# Minimum Spanning Tree

### ê°„ë‹¨ ì„¤ëª…

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë€ ê°€ëŠ¥í•œ Spanning Tree(ì›ë˜ì˜ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ì„œ íŠ¸ë¦¬ì˜ ì†ì„±ì„ ë§Œì¡±í•˜ëŠ” ê·¸ë˜í”„ / no cycle) ì¤‘ì—ì„œ, ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ Spanning Treeë¥¼ ì§€ì¹­í•¨

ëŒ€í‘œì ì¸ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
- Kruskalâ€™s algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜), Prim's algorithm (í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)


### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskal's algorithm)

- ëª¨ë“  ì •ì ì„ ë…ë¦½ì ì¸ ì§‘í•©ìœ¼ë¡œ ë§Œë“ ë‹¤.
- ëª¨ë“  ê°„ì„ ì„ ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê³ , ë¹„ìš©ì´ ì‘ì€ ê°„ì„ ë¶€í„° ì–‘ ëì˜ ë‘ ì •ì ì„ ë¹„êµí•œë‹¤.
- ë‘ ì •ì ì˜ ìµœìƒìœ„ ì •ì ì„ í™•ì¸í•˜ê³ , ì„œë¡œ ë‹¤ë¥¼ ê²½ìš° ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤. (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ìœ¼ë¯€ë¡œ, ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì„)
    * íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ì´ˆë¡œ í•˜ê³  ìˆìŒ (ë‹¹ì¥ ëˆˆ ì•ì˜ ìµœì†Œ ë¹„ìš©ì„ ì„ íƒí•´ì„œ, ê²°ê³¼ì ìœ¼ë¡œ ìµœì ì˜ ì†”ë£¨ì…˜ì„ ì°¾ìŒ)
- Union-Find ì•Œê³ ë¦¬ì¦˜
    * Disjoint Setì„ í‘œí˜„í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ í™œìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
    * ê°„ë‹¨í•˜ê²Œ, ë…¸ë“œë“¤ ì¤‘ì— ì—°ê²°ëœ ë…¸ë“œë¥¼ ì°¾ê±°ë‚˜, ë…¸ë“œë“¤ì„ ì„œë¡œ ì—°ê²°í•  ë•Œ (í•©ì¹  ë•Œ) ì‚¬ìš©
    * Disjoint Setì´ë€
        * ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ì¡°ì‘í•˜ëŠ” ìë£Œêµ¬ì¡°
        * ê³µí†µ ì›ì†Œê°€ ì—†ëŠ” (ì„œë¡œì†Œ) ìƒí˜¸ ë°°íƒ€ì ì¸ ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•¨
        * Disjoint Set = ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°
    * ìˆœì„œ
        1. ì´ˆê¸°í™”
            * n ê°œì˜ ì›ì†Œê°€ ê°œë³„ ì§‘í•©ìœ¼ë¡œ ì´ë¤„ì§€ë„ë¡ ì´ˆê¸°í™”
        2. Union
            * ë‘ ê°œë³„ ì§‘í•©ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹¨, ë‘ íŠ¸ë¦¬ë¥¼ í•˜ë‚˜ì˜ íŠ¸ë¦¬ë¡œ ë§Œë“¬
        3. Find
            * ì—¬ëŸ¬ ë…¸ë“œê°€ ì¡´ì¬í•  ë•Œ, ë‘ ê°œì˜ ë…¸ë“œë¥¼ ì„ íƒí•´ì„œ, í˜„ì¬ ë‘ ë…¸ë“œê°€ ì„œë¡œ ê°™ì€ ê·¸ë˜í”„ì— ì†í•˜ëŠ”ì§€ íŒë³„í•˜ê¸° ìœ„í•´, ê° ê·¸ë£¹ì˜ ìµœìƒë‹¨ ì›ì†Œ (ì¦‰, ë£¨íŠ¸ ë…¸ë“œ)ë¥¼ í™•ì¸
    * ì£¼ì˜ì 
        * Find/Union ì‹œ ê³„ì‚°ëŸ‰ì´ O(N) ì´ ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, í•´ë‹¹ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, union-by-rank, path compression ê¸°ë²•ì„ ì‚¬ìš©í•¨
    * union-by-rank ê¸°ë²•
        * ê° íŠ¸ë¦¬ì— ëŒ€í•´ ë†’ì´(rank)ë¥¼ ê¸°ì–µí•´ ë‘ê³ 
        * Unionì‹œ ë‘ íŠ¸ë¦¬ì˜ ë†’ì´(rank)ê°€ ë‹¤ë¥´ë©´, ë†’ì´ê°€ ì‘ì€ íŠ¸ë¦¬ë¥¼ ë†’ì´ê°€ í° íŠ¸ë¦¬ì— ë¶™ì„ (ì¦‰, ë†’ì´ê°€ í° íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œê°€ í•©ì¹œ ì§‘í•©ì˜ ë£¨íŠ¸ ë…¸ë“œê°€ ë˜ê²Œ í•¨)
        * ë†’ì´ê°€ h - 1 ì¸ ë‘ ê°œì˜ íŠ¸ë¦¬ë¥¼ í•©ì¹  ë•ŒëŠ” í•œ ìª½ì˜ íŠ¸ë¦¬ ë†’ì´ë¥¼ 1 ì¦ê°€ì‹œì¼œì£¼ê³ , ë‹¤ë¥¸ ìª½ì˜ íŠ¸ë¦¬ë¥¼ í•´ë‹¹ íŠ¸ë¦¬ì— ë¶™ì—¬ì¤Œ
        * ì´ˆê¸°í™”ì‹œ, ëª¨ë“  ì›ì†ŒëŠ” ë†’ì´(rank) ê°€ 0 ì¸ ê°œë³„ ì§‘í•©ì¸ ìƒíƒœì—ì„œ, í•˜ë‚˜ì”© ì›ì†Œë¥¼ í•©ì¹  ë•Œ, union-by-rank ê¸°ë²•ì„ ì‚¬ìš©í•œë‹¤ë©´,
        * ë†’ì´ê°€ h ì¸ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§€ë ¤ë©´, ë†’ì´ê°€ h - 1 ì¸ ë‘ ê°œì˜ íŠ¸ë¦¬ê°€ í•©ì³ì ¸ì•¼ í•¨
        * ë†’ì´ê°€ h - 1 ì¸ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ìµœì†Œ nê°œì˜ ì›ì†Œê°€ í•„ìš”í•˜ë‹¤ë©´, ë†’ì´ê°€ h ì¸ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§€ê¸° ìœ„í•´ì„œëŠ” ìµœì†Œ 2nê°œì˜ ì›ì†Œê°€ í•„ìš”í•¨
        * ë”°ë¼ì„œ union-by-rank ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´, union/find ì—°ì‚°ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(N) ì´ ì•„ë‹Œ,  ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘)ë¡œ ë‚®ì¶œ ìˆ˜ ìˆìŒ
    * path compression
        * Findë¥¼ ì‹¤í–‰í•œ ë…¸ë“œì—ì„œ ê±°ì³ê°„ ë…¸ë“œë¥¼ ë£¨íŠ¸ì— ë‹¤ì´ë ‰íŠ¸ë¡œ ì—°ê²°í•˜ëŠ” ê¸°ë²•
        * Findë¥¼ ì‹¤í–‰í•œ ë…¸ë“œëŠ” ì´í›„ë¶€í„°ëŠ” ë£¨íŠ¸ ë…¸ë“œë¥¼ í•œë²ˆì— ì•Œ ìˆ˜ ìˆìŒ
    * union-by-rank ì™€ path compression ê¸°ë²• ì‚¬ìš©ì‹œ ì‹œê°„ ë³µì¡ë„ëŠ” ë‹¤ìŒ ê³„ì‚°ì‹ì„ ë§Œì¡±í•¨ì´ ì¦ëª…ë˜ì—ˆìŒ
        * ğ‘‚(ğ‘€ğ‘™ğ‘œğ‘”âˆ—ğ‘)
        * ğ‘™ğ‘œğ‘”âˆ—ğ‘ì€ ë‹¤ìŒ ê°’ì„ ê°€ì§ì´ ì¦ëª…ë˜ì—ˆìŒ
        * Nì´ 2^265536 ê°’ì„ ê°€ì§€ë”ë¼ë„, ğ‘™ğ‘œğ‘”âˆ—ğ‘ì˜ ê°’ì´ 5ì˜ ê°’ì„ ê°€ì§€ë¯€ë¡œ, ê±°ì˜ O(1), ì¦‰ ìƒìˆ˜ê°’ì— ê°€ê¹ë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ


### íŒŒì´ì¬ìœ¼ë¡œ êµ¬í˜„

- ì•„ë˜ì™€ ê°™ì€ ìœ ë°©í–¥ ê·¸ë˜í”„ë¥¼ kruskalë¡œ íƒìƒ‰í•œë‹¤ë©´,

```python
mygraph = {
    'vertices': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
    'edges': [
        (7, 'A', 'B'),
        (5, 'A', 'D'),
        (7, 'B', 'A'),
        (8, 'B', 'C'),
        (9, 'B', 'D'),
        (7, 'B', 'E'),
        (8, 'C', 'B'),
        (5, 'C', 'E'),
        (5, 'D', 'A'),
        (9, 'D', 'B'),
        (7, 'D', 'E'),
        (6, 'D', 'F'),
        (7, 'E', 'B'),
        (5, 'E', 'C'),
        (7, 'E', 'D'),
        (8, 'E', 'F'),
        (9, 'E', 'G'),
        (6, 'F', 'D'),
        (8, 'F', 'E'),
        (11, 'F', 'G'),
        (9, 'G', 'E'),
        (11, 'G', 'F')
    ]
}
```

ì´ë ‡ê²Œ êµ¬í˜„í•œë‹¤.

```python
def kruskal(graph):
    mst = list()

    # 1. ì´ˆê¸°í™”
    for node in graph['vertices']:
        make_set(node)

    # 2. ê°„ì„  weight ê¸°ë°˜ sorting
    edges = graph['edges']
    edges.sort()

    # 3. ê°„ì„  ì—°ê²° (ì‚¬ì´í´ ì—†ëŠ”)
    for edge in edges:
        weight, node_v, node_u = edge
        if find(node_v) != find(node_u):
            union(node_v, node_u)
            mst.append(edge)

    return mst
```

### ì „ì²´ ì½”ë“œ

```python
mygraph = {
    'vertices': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
    'edges': [
        (7, 'A', 'B'),
        (5, 'A', 'D'),
        (7, 'B', 'A'),
        (8, 'B', 'C'),
        (9, 'B', 'D'),
        (7, 'B', 'E'),
        (8, 'C', 'B'),
        (5, 'C', 'E'),
        (5, 'D', 'A'),
        (9, 'D', 'B'),
        (7, 'D', 'E'),
        (6, 'D', 'F'),
        (7, 'E', 'B'),
        (5, 'E', 'C'),
        (7, 'E', 'D'),
        (8, 'E', 'F'),
        (9, 'E', 'G'),
        (6, 'F', 'D'),
        (8, 'F', 'E'),
        (11, 'F', 'G'),
        (9, 'G', 'E'),
        (11, 'G', 'F')
    ]
}

parent = dict()
rank = dict()


def find(node):
    # path compression ê¸°ë²•
    if parent[node] != node:
        parent[node] = find(parent[node])
    return parent[node]


def union(node_v, node_u):
    root1 = find(node_v)
    root2 = find(node_u)

    # union-by-rank ê¸°ë²•
    if rank[root1] > rank[root2]:
        parent[root2] = root1
    else:
        parent[root1] = root2
        if rank[root1] == rank[root2]:
            rank[root2] += 1


def make_set(node):
    parent[node] = node
    rank[node] = 0

def kruskal(graph):
    mst = list()

    # 1. ì´ˆê¸°í™”
    for node in graph['vertices']:
        make_set(node)

    # 2. ê°„ì„  weight ê¸°ë°˜ sorting
    edges = graph['edges']
    edges.sort()

    # 3. ê°„ì„  ì—°ê²° (ì‚¬ì´í´ ì—†ëŠ”)
    for edge in edges:
        weight, node_v, node_u = edge
        if find(node_v) != find(node_u):
            union(node_v, node_u)
            mst.append(edge)

    return mst
```

- output:
        [(5, 'A', 'D'),
         (5, 'C', 'E'),
         (6, 'D', 'F'),
         (7, 'A', 'B'),
         (7, 'B', 'E'),
         (9, 'E', 'G')]

### ì‹œê°„ ë³µì¡ë„

- í¬ë£¨ìŠ¤ì»¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” O(E log E)
    * ê°„ì„  ìˆ˜: E
    * ë…¸ë“œ ìˆ˜: V
    * ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ì‹œê°„ì— ì¢Œìš°ë¨ (ì¦‰ ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ì‹œê°„ì´ ê°€ì¥ í¼)
    * ê³¼ì •1: ëª¨ë“  ì •ì ì„ ë…ë¦½ì ì¸ ì§‘í•©ìœ¼ë¡œ ë§Œë“ ë‹¤.
        * O(V)
    * ê³¼ì •2: ëª¨ë“  ê°„ì„ ì„ ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê³ , ë¹„ìš©ì´ ì‘ì€ ê°„ì„ ë¶€í„° ì–‘ ëì˜ ë‘ ì •ì ì„ ë¹„êµí•œë‹¤.
        * ğ‘‚(ğ¸ğ‘™ğ‘œğ‘”ğ¸)
    * ê³¼ì •3: ë‘ ì •ì ì˜ ìµœìƒìœ„ ì •ì ì„ í™•ì¸í•˜ê³ , ì„œë¡œ ë‹¤ë¥¼ ê²½ìš° ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤. (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ìœ¼ë¯€ë¡œ, ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì„)
        * union-by-rank ì™€ path compression ê¸°ë²• ì‚¬ìš©ì‹œ ì‹œê°„ ë³µì¡ë„ê°€ ê²°êµ­ ìƒìˆ˜ê°’ì— ê°€ê¹Œì›€, O(1)
        * ğ‘‚(ğ¸)
- ì°¸ê³  - í™í ì‹œê°„ë³µì¡ë„
    * depth (íŠ¸ë¦¬ì˜ ë†’ì´) ë¥¼ hë¼ê³  í‘œê¸°í•œë‹¤ë©´,
    * nê°œì˜ ë…¸ë“œë¥¼ ê°€ì§€ëŠ” heap ì— ë°ì´í„° ì‚½ì… ë˜ëŠ” ì‚­ì œì‹œ, ìµœì•…ì˜ ê²½ìš° root ë…¸ë“œì—ì„œ leaf ë…¸ë“œê¹Œì§€ ë¹„êµí•´ì•¼ í•˜ë¯€ë¡œ h=log2n ì— ê°€ê¹Œìš°ë¯€ë¡œ, ì‹œê°„ ë³µì¡ë„ëŠ” O(logn)


### í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Prim's algorithm)

- ì‹œì‘ ì •ì ì„ ì„ íƒí•œ í›„, ì •ì ì— ì¸ì ‘í•œ ê°„ì„ ì¤‘ ìµœì†Œ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ì •ì ì—ì„œ ë‹¤ì‹œ ìµœì†Œ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ì„ ì„ íƒí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ í™•ì¥í•´ê°€ëŠ” ë°©ì‹
- Kruskal's algorithm ê³¼ Prim's algorithm ë¹„êµ
    * ë‘˜ë‹¤, íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ì´ˆë¡œ í•˜ê³  ìˆìŒ (ë‹¹ì¥ ëˆˆ ì•ì˜ ìµœì†Œ ë¹„ìš©ì„ ì„ íƒí•´ì„œ, ê²°ê³¼ì ìœ¼ë¡œ ìµœì ì˜ ì†”ë£¨ì…˜ì„ ì°¾ìŒ)
    * Kruskal's algorithmì€ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒí•˜ë©´ì„œ MSTë¥¼ êµ¬í•¨
    * Prim's algorithmì€ íŠ¹ì • ì •ì ì—ì„œ ì‹œì‘, í•´ë‹¹ ì •ì ì— ì—°ê²°ëœ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ ì„ íƒ, ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ë“¤ì— ì—°ê²°ëœ ê°„ì„  ì¤‘ì—ì„œ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ íƒí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ MSTë¥¼ êµ¬í•¨
- ìˆœì„œ
    * ì„ì˜ì˜ ì •ì ì„ ì„ íƒ, 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì‚½ì…
    * ì„ íƒëœ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
    * ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê°„ì„ ë¶€í„° ì¶”ì¶œí•´ì„œ,
        * í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì´ë¯¸ ë“¤ì–´ ìˆë‹¤ë©´, ìŠ¤í‚µí•¨(cycle ë°œìƒì„ ë§‰ê¸° ìœ„í•¨)
        * í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ë“¤ì–´ ìˆì§€ ì•Šìœ¼ë©´, í•´ë‹¹ ê°„ì„ ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ê°„ì„  ì •ë³´ë¥¼ 'ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬'ì— ì‚½ì…
            * í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì˜ ê°„ì„ ë“¤ ì¤‘, 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©(connected_nodes)' ì— ì—†ëŠ” ë…¸ë“œì™€ ì—°ê²°ëœ ê°„ì„ ë“¤ë§Œ ê°„ì„  ë¦¬ìŠ¤íŠ¸(candidate_edge_list) ì— ì‚½ì…
    * ì¶”ì¶œí•œ ê°„ì„ ì€ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°
    * ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ë” ì´ìƒì˜ ê°„ì„ ì´ ì—†ì„ ë•Œê¹Œì§€ 3-4ë²ˆì„ ë°˜ë³µ


### íŒŒì´ì¬ìœ¼ë¡œ êµ¬í˜„

- heapq ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©ì„ í†µí•´ ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•œë‹¤.

ì•„ë˜ì™€ ê°™ì€ ìœ ë°©í–¥ ê·¸ë˜í”„ë¥¼ primìœ¼ë¡œ íƒìƒ‰í•œë‹¤ë©´,

```python
myedges = [
    (7, 'A', 'B'), (5, 'A', 'D'),
    (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E'),
    (5, 'C', 'E'),
    (7, 'D', 'E'), (6, 'D', 'F'),
    (8, 'E', 'F'), (9, 'E', 'G'),
    (11, 'F', 'G')
]
```

ì´ë ‡ê²Œ êµ¬í˜„í•œë‹¤.

```python
def prim(start_node, edges):
    mst = list()
    adjacent_edges = defaultdict(list)
    for weight, n1, n2 in edges:
        adjacent_edges[n1].append((weight, n1, n2))
        adjacent_edges[n2].append((weight, n2, n1))

    connected_nodes = set(start_node)
    candidate_edge_list = adjacent_edges[start_node]
    heapify(candidate_edge_list)

    while candidate_edge_list:
        weight, n1, n2 = heappop(candidate_edge_list)
        if n2 not in connected_nodes:
            connected_nodes.add(n2)
            mst.append((weight, n1, n2))

            for edge in adjacent_edges[n2]:
                if edge[2] not in connected_nodes:
                    heappush(candidate_edge_list, edge)

    return mst
```

### ì „ì²´ ì½”ë“œ

```python
myedges = [
    (7, 'A', 'B'), (5, 'A', 'D'),
    (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E'),
    (5, 'C', 'E'),
    (7, 'D', 'E'), (6, 'D', 'F'),
    (8, 'E', 'F'), (9, 'E', 'G'),
    (11, 'F', 'G')
]

from collections import defaultdict
from heapq import *

def prim(start_node, edges):
    mst = list()
    adjacent_edges = defaultdict(list)
    for weight, n1, n2 in edges:
        adjacent_edges[n1].append((weight, n1, n2))
        adjacent_edges[n2].append((weight, n2, n1))

    connected_nodes = set(start_node)
    candidate_edge_list = adjacent_edges[start_node]
    heapify(candidate_edge_list)

    while candidate_edge_list:
        weight, n1, n2 = heappop(candidate_edge_list)
        if n2 not in connected_nodes:
            connected_nodes.add(n2)
            mst.append((weight, n1, n2))

            for edge in adjacent_edges[n2]:
                if edge[2] not in connected_nodes:
                    heappush(candidate_edge_list, edge)

    return mst
```

- output:
        [(5, 'A', 'D'),
        (6, 'D', 'F'),
        (7, 'A', 'B'),
        (7, 'B', 'E'),
        (5, 'E', 'C'),
        (9, 'E', 'G')]

### ì‹œê°„ ë³µì¡ë„

- ìµœì•…ì˜ ê²½ìš°, while êµ¬ë¬¸ì—ì„œ ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ ë°˜ë³µí•˜ê³ , ìµœì†Œ í™ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ O(ğ¸ğ‘™ğ‘œğ‘”ğ¸) ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§
    * ê°„ì„  ìˆ˜: E
    * ë…¸ë“œ ìˆ˜: V
- ì°¸ê³  - ê°œì„ ëœ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜
    * ê°„ì„ ì´ ì•„ë‹Œ ë…¸ë“œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ ì ìš©í•˜ëŠ” ë°©ì‹
        * ì´ˆê¸°í™” - ì •ì :key êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ë†“ê³ , íŠ¹ì • ì •ì ì˜ keyê°’ì€ 0, ì´ì™¸ì˜ ì •ì ë“¤ì˜ keyê°’ì€ ë¬´í•œëŒ€ë¡œ ë†“ìŒ. ëª¨ë“  ì •ì :key ê°’ì€ ìš°ì„ ìˆœìœ„ íì— ë„£ìŒ
        * ê°€ì¥ keyê°’ì´ ì ì€ ì •ì :keyë¥¼ ì¶”ì¶œí•œ í›„(pop í•˜ë¯€ë¡œ í•´ë‹¹ ì •ì :key ì •ë³´ëŠ” ìš°ì„ ìˆœìœ„ íì—ì„œ ì‚­ì œë¨), (extract min ë¡œì§ì´ë¼ê³  ë¶€ë¦„)
        * í•´ë‹¹ ì •ì ì˜ ì¸ì ‘í•œ ì •ì ë“¤ì— ëŒ€í•´ key ê°’ê³¼ ì—°ê²°ëœ ê°€ì¤‘ì¹˜ ê°’ì„ ë¹„êµí•˜ì—¬ keyê°’ì´ ì‘ìœ¼ë©´ í•´ë‹¹ ì •ì :key ê°’ì„ ê°±ì‹ 
            * ì •ì :key ê°’ ê°±ì‹ ì‹œ, ìš°ì„ ìˆœìœ„ íëŠ” ìµœì†Œ keyê°’ì„ ê°€ì§€ëŠ” ì •ì :key ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ì˜¬ë ¤ë†“ë„ë¡ ì¬êµ¬ì„±í•¨ (decrease key ë¡œì§ì´ë¼ê³  ë¶€ë¦„)
    * ê°œì„ ëœ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì‹œ ê³ ë ¤ ì‚¬í•­
        * ìš°ì„ ìˆœìœ„ í(ìµœì†Œí™) êµ¬ì¡°ì—ì„œ, ì´ë¯¸ ë“¤ì–´ê°€ ìˆëŠ” ë°ì´í„°ì˜ ê°’ ë³€ê²½ì‹œ, ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ë°ì´í„°ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ì˜¬ë ¤ë†“ë„ë¡ ì¬êµ¬ì„±í•˜ëŠ” ê¸°ëŠ¥ì´ í•„ìš”í•¨
        * êµ¬í˜„ ë³µì¡ë„ë¥¼ ì¤„ì´ê¸° ìœ„í•´, heapdict ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•´, í•´ë‹¹ ê¸°ëŠ¥ì„ ê°„ë‹¨íˆ êµ¬í˜„

    ```python
    from heapdict import heapdict

    def prim(graph, start):
        mst, keys, pi, total_weight = list(), heapdict(), dict(), 0
        for node in graph.keys():
            keys[node] = float('inf')
            pi[node] = None
        keys[start], pi[start] = 0, start

        while keys:
            current_node, current_key = keys.popitem()
            mst.append([pi[current_node], current_node, current_key])
            total_weight += current_key
            for adjacent, weight in mygraph[current_node].items():
                if adjacent in keys and weight < keys[adjacent]:
                    keys[adjacent] = weight
                    pi[adjacent] = current_node
        return mst, total_weight

    mygraph = {
    'A': {'B': 7, 'D': 5},
    'B': {'A': 7, 'D': 9, 'C': 8, 'E': 7},
    'C': {'B': 8, 'E': 5},
    'D': {'A': 5, 'B': 9, 'E': 7, 'F': 6},
    'E': {'B': 7, 'C': 5, 'D': 7, 'F': 8, 'G': 9},
    'F': {'D': 6, 'E': 8, 'G': 11},
    'G': {'E': 9, 'F': 11}    
    }
    mst, total_weight = prim(mygraph, 'A')
    print ('MST:', mst)
    print ('Total Weight:', total_weight)
    ```

    * ê°œì„ ëœ í”„ë¦¼ ì‹œê°„ë³µì¡ë„ ğ‘‚(ğ¸ğ‘™ğ‘œğ‘”ğ‘‰)
        * ìµœì´ˆ key ìƒì„± ì‹œê°„ ë³µì¡ë„: ğ‘‚(ğ‘‰)
        * while êµ¬ë¬¸ê³¼ keys.popitem() ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” ğ‘‚(ğ‘‰ğ‘™ğ‘œğ‘”ğ‘‰)
            * while êµ¬ë¬¸ì€ V(ë…¸ë“œ ê°¯ìˆ˜) ë²ˆ ì‹¤í–‰ë¨
            * heap ì—ì„œ ìµœì†Œ key ê°’ì„ ê°€ì§€ëŠ” ë…¸ë“œ ì •ë³´ ì¶”ì¶œ ì‹œ(pop)ì˜ ì‹œê°„ ë³µì¡ë„:  ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘‰)
        * for êµ¬ë¬¸ì˜ ì´ ì‹œê°„ ë³µì¡ë„ëŠ” ğ‘‚(ğ¸ğ‘™ğ‘œğ‘”ğ‘‰)
            * for êµ¬ë¬¸ì€ while êµ¬ë¬¸ ë°˜ë³µì‹œì— ê²°ê³¼ì ìœ¼ë¡œ ì´ ìµœëŒ€ ê°„ì„ ì˜ ìˆ˜ Eë§Œí¼ ì‹¤í–‰ ê°€ëŠ¥ ğ‘‚(ğ¸)
            * for êµ¬ë¬¸ ì•ˆì—ì„œ keyê°’ ë³€ê²½ì‹œë§ˆë‹¤ heap êµ¬ì¡°ë¥¼ ë³€ê²½í•´ì•¼ í•˜ë©°, heap ì—ëŠ” ìµœëŒ€ V ê°œì˜ ì •ë³´ê°€ ìˆìœ¼ë¯€ë¡œ ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘‰)
            
    > ì¼ë°˜ì ì¸ heap ìë£Œ êµ¬ì¡° ìì²´ì—ëŠ” ë³¸ë˜ heap ë‚´ë¶€ì˜ ë°ì´í„° ìš°ì„ ìˆœìœ„ ë³€ê²½ì‹œ, ìµœì†Œ ìš°ì„ ìˆœìœ„ ë°ì´í„°ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ë¡œì§ì€ ì—†ìŒ. ì´ë¥¼ decrease key ë¡œì§ì´ë¼ê³  ë¶€ë¦„, í•´ë‹¹ ë¡œì§ì€ heapdict ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•´ì„œ ê°„ë‹¨íˆ ì ìš©ê°€ëŠ¥

* ì°¸ê³ ìë£Œ - fastcampus: ì•Œê³ ë¦¬ì¦˜    
