# Part 5-1 BackEnd

* [Maven vs Gradle](#Maven-vs-Gradle)
* [Servlet](#Servlet)
* [JUnit](#JUnit)
* [Apache and Tomcat](#Apache-and-Tomcat)
* [JSON](#JSON)
* [Logging](#Logging)
* [AssertJ](#AssertJ)
* [MVC](#MVC)
* [H2DB](#H2DB)
* [JDBC](#JDBC)
* [동시성 문제](#동시성-문제)
* [REST API](#REST-API)
* [TDD](#TDD)
* [소프트웨어 아키텍처](#소프트웨어-아키텍처)
* [애자일 방법론](#애자일-방법론)

[뒤로](https://github.com/jhun0514/Today_I_Learn)

</br>

---

## Maven vs Gradle

### Maven
- 역할: 아파치 메이븐은 자바용 프로젝트 관리 도구이다. 아파치 앤트의 대안으로 만들어졌다. 아파치 라이선스로 배포되는 오픈소스 소프트웨어이다. 한마디로 저희가 프로젝트를 진행하면서 사용할 수많은 라이브러리들을 관리해주는 도구입니다.
- 특징:
  * 연관된 라이브러리들 까지 거미줄처럼 다 연동이 되어 관리가 된다. (네트워크를 통해 업데이트)

### Gradle
- 역할: Groovy(자바머신에서 실행되는 스크립트 언어이다, 하지만 소스코드를 컴파일 할 필요는 없다)를 이용한 빌드 자동화 시스템이다. Groovy 기반의 DSL(Domain Specific Language)를 사용한다. Groovy와 유사한 도메인 언어를 채용하였으며, 현재 안드로이드 앱을 만드는데 필요한 안드로이드 스튜디오의 공식 빌드 시스템이다. 여러 언어를 지원한다.
- 특징:
  * 특히 자바와 거의 비슷한 코드를 써서 빌드를 관리 할 수 있다.

### 결론
- Gradle이 조금 더 빠른 성능과 간결한 설정의 매력을 보유하고 있어 인기도가 상승중이라고 합니다. 규모가 커질수록 그래들이 유리하다고 한다. Maven은 프로젝트가 커질수록 빌드 스크립트의 내용이 길어지고 가독성이 떨어지는 반면, Gradle은 훨씬 적은 양의 스크립트로 짧고 간결하게 작성할 수 있다.
- Maven은 멀티 프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 상속을 받아야 하지만 Gradle 은 설정 주입방식으로 이를 해결한다.
- 그래서 Gradle은 멀티프로젝트에 매우 적합하며 빌드속도는 다양한 시나리오 상에서 10~100배 가량 빠르다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)

</br>

---

## Servlet

- 역할: 서블릿은 클라이언트의 요청을 처리하고 그결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹프로그래밍 기술. 간단히 서블릿이란 자바를 이용하여 웹을 만들기 위해 필요한 기술이다. 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램입니다. 예를 들어, 어떠한 사용자가 로그인을 하려고 할 때, 사용자는 아이디와 비밀번호를 입력하고 로그인 버튼을 누른다. 이때 서버는 클라이언트의 아이디와 비밀번호를 확인하고 페이지를 띄워주어야 하는데 이 역할을 수행하는것이 바로 서블릿입니다.
- 특징:
  * 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
  * Html 을 사용하여 요청에 응답한다.
  * Java Thread를 이용하여 동작한다.
  * MVC 패턴에서 Controller로 이용된다.
  * HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.
  * UDP보다 처리속도가 느리다.
  * HTML변경시 Servlet을 재 컴파일 해야 하는 단점이 있다.
- 부가설명: 일반적으로 웹서버는 정적인 페이지만 제공한다. 동적인 페이지를 제공하기 위해서 웹서버는 다른 곳에 도움을 요청하여 동적인 페이지를 작성해야 한다. 동적인 페이지로는 임의의 이미지만을 보여주는 페이지 같이 사용자가 요청한 시점에 페이지를 생성해서 전달해 주는 것을 의미한다. 여기서 웹서버가 동적인 페이지를 제공할 수 있도록 도와주는 어플리케이션이 서블릿이며 동적인 페이지를 생성하는 어플리케이션이 CGI(특별한 도구가 아닌 별도로 제작된 웹서버와 프로그램간의 교환방식)입니다.
- 동작 방식:
  * 사용자(클라)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송합니다.
  * 요청을 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
  * web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
  * 해당 서블릿에서 service메소드를 호출한 후 클라이언트의 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
  * doGet() doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보냅니다.
  * 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체 모두 소멸시킵니다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://mangkyu.tistory.com/14)

</br>

---

## JUnit

- 역할: JUnit 이란 자바의 단위 테스팅 도구이다. 단하나의 jar파일로 되어 있다. Testing 결과를 단순히 문서로 남기는 것이 아니라 Test Class를 그대로 남김으로써 추후 개발자에게 테스트 방법 및 클래스의 History를 넘겨줄 수 있다. 단위 테스트를 하기 위해서는 가짜 프로그램, 객체를 만들어서 활용할 수 있으며, 정교하게 테스트 하기 위해서는 테스트 케이스 작성은 필수라 할 수 있다.
- 특징:
  * 단위 테스트 프레임워크중 하나이다.
  * [단정문](http://junit.sourceforge.net/javadoc/org/junit/Assert.html)으로 테스트 케이스의 수행결과를 판별
  * Annotation(@)으로 간결하게 사용가능
- 단위 테스트 장점:
  * 개발단계 초기에 문제를 발견할 수 있게 도와줌
  * 리펙토링 또는 라이브러리 업그레이드 등에서 기능 확인을 도와줌(회귀 테스트)
  * 기능에 대한 불확실성 감소
  * 시스템에 대한 실제 문서 또는 예제로써 사용가능
  * 빠른 피드백과 기능을 안전하게 보호가능

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://galid1.tistory.com/476)

</br>

---

## Apache and Tomcat

### 웹서버
- 의미: 소프트웨어 측면에서 웹서버는 기본적으로 웹 사용자가 어떻게 호스트 파일들에 접근하는지를 관리합니다.

### Apache
- 역할: 세계에서 가장 많이 쓰는 웹서버 중 하나이며, 아파치 소프트웨어 재단에서 관리하는 HTTP 웹서버이다. 워낙 다양한 추가기능에 구축이 쉽다는 이유 때문에 많이 쓰이고 있다.

### Tomcat
- 역할: 웹 어플리케이션 서버 (WAS)로써 자바 서블릿을 실행시키고 JSP코드가 포함되어 있는 웹페이지를 만들어 준다. 웹서버에서 넘어온 동적인 페이지를 읽어들여 프로그램을 실행하고 그 결과를 다시 HTML로 재구성하여 아파치에게 되돌려 준다.

### 차이점
- 아파치 = 웹서버 / 톰캣 = WAS (웹서버와 서블릿 컨테이너의 결합으로 다양한 역할을 수행하는 서버)
- 차이의 핵심은 컨테이너 기능(웹서버 + 서블릿)이 가능한가 아닌가 이다.
- 웹서버는 정적인 데이터를 처리하는 서버로 단순 이미지나 html파일 같은 리소스만 제공하는 서버는 웹서버만 사용하여 빠르고 안정적이게 활용한다.
- WAS는 동적인 데이터를 처리하는 서버로 DB로 연결되어 데이터를 주고 받거나 자바등을 통해 데이터 조작이 필요한 경우에는 WAS를 활 (서버 시작시 가장먼저 Web.xml 을 읽어드린다. Web.xml 을 기반으로 서버가 돌아가기 위해 필요한 내용을 읽어 드린다)

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)

</br>

---

## JSON

- 의미: JavaScript Object Notation 이라는 의미의 축약어로 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 DATA 교환 형식이다. 자바스크립트에서 객체를 만들때 사용하는 표현식을 의미한다. 데이터 포맷일 뿐이며 어떠한 통신방법도, 프로그래밍 문법도 아닌 단순히 데이터를 표시하는 표현 방법일 뿐이다.

- 특징:
  * 서버와 클라이언트 간의 교류에서 일반적으로 많이 사용된다.
  * 자바스크립트 객체 표기법과 아주 유사하다.
  * 자바스크립트를 이용하여 JSON 형식의 문서를 쉽게 자바스크립트 객체로 변환할 수 있는 이점이 있다.
  * 문서 형식은 자바스크립트 객체의 형식을 기반으로 만들어졌다.
  * 자바스크립트 문법과 굉장히 유사하지만 텍스트 형식일 뿐이다.
  * 다른 프로그래밍 언어를 이용해서도 쉽게 만들 수 있다.
  * 특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON 포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공한다.

### XML vs JSON
- 데이터를 나타낼 수 있는 방식 중 대표적인 것이 XML이고 이후 가장 많이 사용되는 것이 JSON이다.
- XML은 데이터 값 양쪽으로 태그가 있다. (HTML이 근본이기 때문)
- JSON은 태그로 표현하기 보다는 중괄호 같은 형식으로 하고 값을 ','로 나열하기에 표현이 간단하다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://velog.io/@surim014/JSON이란-무엇인가)

</br>

---

## Logging

- 의미: 로깅은 비 기능 요구사항에 속한다. 그러나 고객의 요구여부에 상관없이 로그 출력기능은 프로그램 개발 중 디버깅 및 개발 완료 후 문제 발생시 원인 분석을 위해 좋은 프로그램이 필수적으로 갖추어야 하는 요구조건에 속한다.

- 특징:
  * 정보를 제공하는 일련의 기록인 로그를 생성하도록 시스템을 작성하는 활동을 말한다.
  * 로그는 재형하기 힘든 (개발완료된 환경에서는 발생하지만 테스트 환경에서는 재현할 수 없는) 버그에 대한 유용한 정보를 제공할 수 있다.
  * 로그는 구문들 사이에 걸리는 시간과 같이 성능에 관한 통계와 정보를 제공할 수 있다.
  * 설정이 가능할 때, 로그는 예기치 못한 특정 문제들을 디버그 하기 위해, 그 문제들을 처리하도록 코드를 수정하여 다시 적용하지 않아도 일반적인 정보를 갈무리할 수 있게 한다.

- 로그 출력방법:
  * print 메소드를 이용해 실행 중 다양한 값들을 출력하는 것은 로그의 양을 조절할 수 없고 표준 출력을 통해 출력하는 것은 로그를 파일 등에 저장하는 성능 면에서도 낮은 편에 속한다.
  * 다양한 로깅 라이브러리를 이용한다.
    * java.util.logging: 자바 표준 로그 API이다. 별도의 라이브러리를 추가할 필요가 없는 점이 장점이나 제공하는 기능이 가장 적다. [예시](http://www.gisdeveloper.co.kr/?p=5174)
    * Apache Commons Logging: 아파치 서버나 톰캣 서버만 제공하는것이 아니다.
    * LogBack: 제공하는 기능이 많고 메뉴얼이 상세하다.

- 로그

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)

</br>

---

## AssertJ

- 의미: 자바 테스트를 위해 좀 더 풍부한 문법을 제공하고 메서드 체이닝을 통해 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다.

- 특징:
  * 메소드 체이닝을 지원하기에 더 깔끔하고 읽기 쉬운 테스트코드를 작성할 수 있다.
  * 상상할 수 있는 거의 모든 메소드를 제공한다.
  * JUnit과 자주 같이 쓰인다.

- 로그

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)

</br>

---

## MVC

- 의미: Model, View, Controller 의 구조의 역할 분담 패턴이다. 개발자 디자이너 간 협업이 원활해진다.

### Model
- 데이터와 관련된 일, 저장, 가공 등 비지니스 로직과 관련된 부분을 처리한다. 데이터베이스 관련 로직을 구현한다.
- JSP Beans, EJB Component

### View
- 사용자에게 알맞은 화면을 보여주는 역할을 수행한다. 데이터를 시각적으로 표현하는 것으로 결과값 출력, 사용자요구, 사용자 데이터 입력 등 이 있.
- JSP, CustomTag

### Controller
- Model과 View를 연결해주기 위한 매개체이다. 사용자가 View를 통해 입력을 하면 Model을 변경해주는 것이다. 어플리케이션의 흐름제어나 사용자의 처리요청을 구현한다. 사용자 인증, 보안설정이라든지 전체 어플리케이션에 영향을 미치는 요소를 구현한다. Model과 View는 나눠서 본인의 일에 집중할 수 있도록 컨트롤 해준다. 비용절감, 유지보수, 업부분담이 장접이다.
- Servlet

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://fora.tistory.com/31)

</br>

---

## H2DB

- 의미: 자바 기반의 오픈소스 관계형 데이터 베이스 관리 시스템이다. 서버모드와 임베디드모드의 인메모리 DB기능을 지원한다. 디스크 기반 테이블 또한 생서가능하다.
- 특징:
  * 브라우저 기반의 콘솔모드를 사용할 수 있다.
  * 설치과정이 없고 용량도 매우 저용량이다
  * 매우 가볍고 빠르며 JDBC API 또한 지원한다.
  * SQL 문법은 다른 DBMS와 마찬가지로 표준 SQL의 대부분이 지원된다.
  * 이러한 장점들 때문에 테스트 DB로 많이 이용된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)

</br>

---

## JDBC

- 의미: 자바에서 DB 프로그래밍을 하기위해 사용되는 API
- 특징:
  * 데이터 베이스 종류에 상관없다.
  * JDBC 코딩 흐름 (JDBC 드라이버 로드 -> DB 연결 -> DB에 데이터를 읽거나 쓰기 -> DB 연결 종류)

### JDBC 드라이버
- DBMS와 통신을 담당하는 자바 클래스
- DBMS 별로 알맞은 JDBC 드라이버 필요 (jar)
- 로딩코드: Class.forName("JDBC 드라이버 이름") / ex) mysql: com.mysql.jdbc.Driver

### JDBC URL
- DBMS와 연결을 위한 식별 값
- JDBC 드라이버에 따라 형식이 다르다
- 구성: jdbc:[DBMS]:[데이터베이스 식별자] / ex) jdbc:mysql://HOST[:PORT]/DBNAME[?param=value&param1=value2&..]

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://dyjung.tistory.com/50)

</br>

---

## 동시성 문제

- 의미: 동시에 변수에 접근할 때 발생하는 문제
- 예제 상황: 동시에 여러 스레드가 접근하여 첫 번째 동작할 때의 자원과 두 번째 동작할 때의 자원상태가 변한다.

### 암시적 Lock
- 가장 간단하게 해결하는 방법은 Lock을 걸어 버리는 것이다. Lock을 적용하면 하나의 스레드가 해당 메서드를 실행하고 있을 때 다른 메서드가 해당 메서드를 실행하지 못하고 대기하게 된다.
- synchronized 키워드를 붙이면 암시적 락이 걸린다.

### Volatile
- 메인 메모리에 저장된 실제 자원의 값을 볼 수 있는 개념을 자원의 가시성이라 부르는데 volatile은 이러한 cpu 캐시 사용(자원의 가시성이 없다)을 막는다
- 변수에 volatile 키워드를 붙이면 해당 변수는 캐시에 저장되는 대상에서 제외된다. 매번 메모리에 접근하여 실제 값을 읽어온다.
- 하나의 스레드가 write하고 다른 하나가 read할 경우에만 효과적이다.

### 안전한 객체
- ConcurrentHashMap은 내부적으로 여러개의 락을 가지고 해시값을 이용해 락을 분할 하여 사용한다. 병렬성과 성능이라는 두마리의 토끼를 모두잡은 컬랙션이다.

### 불변 객체
- setter를 만들지 않고 변수를 final로 선언한다. 언제라도 안전해진다. 하지만 그만큼 단점도 있다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://deveric.tistory.com/104)

</br>

---

## REST API

- 의미: REST는 Representational State Transfer라는 용어의 약자이다. 쉽게 말해 REST API는 다음의 구성으로 이루어져있습니다.
  * 자원(RESOURCE) - URI
  * 행위(Verb) - HTTP METHOD
  * 표현(Representations)

### 특징
- Uniform Interface: URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.
- Stateless: REST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.
- Cacheable: REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.
- Self-descriptiveness: REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.
- Client - Server: REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.
- 계층형: REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.

### REST API 디자인 가이드
- URI는 정보의 자원을 표현해야 한다.
- 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.

### URI 설계 시 주의할 점
- 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용
- URI 마지막 문자로 슬래시(/)를 포함하지 않는다.
- 하이픈(-)은 URI 가독성을 높이는데 사용
- 밑줄(_)은 URI에 사용하지 않는다.
- URI 경로에는 소문자가 적합하다.
- 파일 확장자는 URI에 포함시키지 않는다. (Accept header를 사용하도록 한다)

### 리소스 간의 관계를 표현하는 방법
- REST 리소스 간에는 연관 관계가 있을 수 있고 이 경우 (/리소스명/리소스 ID/관계가 있는 다른 리소스명) 이렇게 표현 한다.
- 관계명이 복잡하다면 이를 서브 리소스에 명시적으로 표현하는 방법이 있다 (/users/{userid}/likes/devices)

### 자원을 표현하는 Colllection과 Document
- ex) http:// restapi.example.com/sports/soccer/players/13
- sports, players 컬렉션과 soccer, 13(13번인 선수)를 의미하는 도큐먼트로 URI가 이루어지게 됩니다.
- 여기서 중요한 점은 컬렉션은 복수로 사용하고 있다는 점입니다.

### HTTP 응답 상태 코드
- 잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 한다.
- ex) 2xx 나 4xx 코드

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://chanhuiseok.github.io/posts/spring-5/)/[참고자료](https://meetup.toast.com/posts/92)

</br>

---

## TDD

- 의미: TDD(Test Driven Development)는 테스트 주도 개발로 반복 테스트를 이용한 소프트웨어 방법론이다. 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현한다.

### 특징
- 짧은 개발주기의 반복에 의존하는 개발 프로세스이며 애자일 방법론 중 하나인 XP(eXtream Programming)의 Test-First 개념에 기반을 둔 단순한 설계를 중요시한다.

### 개발주기
- 1단계에서는 실패하는 테스트 코드를 먼저 작성한다.
- 2단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.
- 3단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다.
- 중요한 것은 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는 것과 실패하는 테스트를 통과할 정도의 최소 실제 코드를 작성해야 하는 것이다. 이를 통해 실제 코드에 대해 기대되는 바를 보다 명확하게 정의함으로써 불필요한 설계를 피할 수 있고, 정확한 요구 사항에 집중할 수 있다.

### 일반 개발 방식 과의 차이점
- 보통의 개발 방식은 분석 -> 설계 -> 개발 -> 테스트 -> 배포의 형태를 갖는다. 이는 개발을 느리게하는 잠재적 위험이 존재한다.
  * 소비자의 요구사항이 처음부터 명확하지 않을 수 있다.
  * 따라서 처음부터 완벽한 설계는 어렵다
  * 자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다.
  * 자체 테스트 비용이 증가할 수 있다.
  * 개발 도중 코드 삽입, 수정, 삭제하는 과정에서 불필요한 코드가 남거나 중복처리 될 가능성이 크다.
  * 결론적으로 이러한 코드들은 재사용이 어렵고 관리가 어려워져 유지보수를 어렵게 만든다.

- TDD 개발 방식은 테스트 코드를 작성한 뒤에 실제 코드를 작성한다.
  * 설계 단계에서 프로그래밍 목적을 미리 정의 해야하고 무엇을 테스트 할지 정의 해야한다.
  * 테스트 코드를 작성하는 도중 발생하는 예외사항(버그,수정사항) 들은 테스트 케이스에 추가하고 설계를 개선한다.
  * 이후 테스트가 통과된 코드만을 코드 개발 단계에서 실제 코드로 작성한다.

### JUnit
- 대표적인 TDD 툴이다.

### 장점
- 보다 튼튼한 객체 지향적인 코드 생산
- 재설계 시간의 단축
- 디버깅 시간의 단축
- 테스트 문서의 대체 가능
- 추가 구현의 용이함

### 단점
- 생산성의 저하 (처음부터 2개의 코드를 짜야하기 때문, 중간중간 테스트를 통해 고쳐나가야 하기 때문)
- 개발하던 방식을 바꿔야한다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://wooaoe.tistory.com/33)

</br>

---

## 소프트웨어 아키텍처

- 의미: 애플리케이션을 구축할 때 사용하는 패턴과 기술을 설명합니다. 로드맵과 모법사례를 제공하여 체계적으로 구성된 애플리케이션을 완성할 수 있게 해줍니다.

### N-티어
- 엔터프라이즈 애플리케이션을 구축할 때 흔히 사용하는 전통 아키텍처이다
- 주로 3개 티어 또는 레이어로 구성되지만 이보다 많을 수 있으며 각각 책임이 지정된 티어가 애플리케이션을 구성합니다.
- 레이어는 수평으로 배열되기 때문에 바로 아래 있는 레이어만 호출할 수 있습니다.

### 모놀리식
- 애플리케이션 내 모든 기능을 포함한 단일 애플리케이션 스택이다.
- 단일 측면을 업데이트 하거나 확장하는 경우 전체 애플리케이션은 물론 기반 인프라에도 영향을 미칩니다.
- 일반적인 유지관리만 진행하는 경우가 많다.

### 마이크로서비스
- 상호 독립적인 최소 구성 요소로 분할한다.
- 서로 영향을 미치지 않고 동적인 확장성과 결함 허용 측면 모두 장점이있다.
- 변경사항이 있더라도 전체를 다시 빌드하거나 배포할 필요가 없다.
- 상대적으로 많이 복잡하고 통합 테스트가 어렵다

### 이벤트 기반
- 최소한의 결합을 지원한다.
- 이벤트 생성자와 소비자로 구성 되어 있으며 생성자는 이벤트를 감지하여 메세지로 나타낸다. 생성자는 소비자 또는 이벤트 결과를 알지 못한다.
- 이벤트 감지 후헤는 이벤트 채널을 통해 소비자로 전송된다.

### 서비스 지향
- 마이크로서비스와 유사하며 별개의 재사용 가능한 서비스 단위로 분할 한다.
- 특정 비지니스 프로세스를 기반으로 구성된 개별 서비스가 통신 프로토콜을 준수하며 ESB(Enterprise Service Bus)의 플랫폼을 통해 공유된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://www.redhat.com/ko/topics/cloud-native-apps/what-is-an-application-architecture)

</br>

---

## 애자일 방법론

- 의미: Agile 방법론은 구체적인 개발 프로세스가 아닌 개발 지침에 가깝다.

### 특징
- 변화를 수용하고 협업과 제품의 빠른 인도를 강조하는 반복적 개발 방법
- 문서화보다 코드, 프로그램, 소프트웨어 자체를 중요시 함
- 요구사항이 바뀌기 쉬운 중소형의 비지니스 시스템이나 전자 상거래 응용에 적합하다.

### 선언문
- 공정과 도구보다 개인과 상호작용을
- 포괄적인 문서보다 작동하는 소프트웨어를
- 계약 협상보다 고객과의 협력을
- 계획을 따르기보다 변화에 대응하기를

### 종류
- 익스트림 프로그래밍
  * XP(Extreme Programming)
  * 작고 빈번한 릴리즈 - 빠른 피드백과 지속적 개선
  * 고객도 개발팀의 일원
  * 프로세스 중심이 아닌 사람중심
  * 짝 프로그래밍
  * 단순한 설계와 TDD
  * 리펙토링을 통한 코드 품질 개선
- 짝 프로그래밍
  * 두 사람이 짝이 되어 한사람이 코딩, 다른사람은 검사를 수행
  * 30분 마다 역할 교체
  * 코드에 대한 책임 공유
  * 비형식적 검토 수행
  * 리팩토링 장려
  * 생산성이 떨어지지 않는다
- TDD
  * 테스트 케이스를 먼저 작성하고 이를 통과하는 코드를 개발
  * Task 별로 테스트 케이스를 만듦
  * 통합 테스트를 강조하며 통합과정에서 기존 소프트웨어에 오류 유입 방지
- 스크럼
  * 솔루션에 포함할 기능, 개선점에 대한 우선 순위를 부여한다.
  * 개발 주기는 30일 정도로 조절하고 개발 주기마다 실제 동작할 수 있는 결과를 제공하라
  * 개발 주기마다 적용할 기능이나 개선에 대한 목록을 제공하라
  * 날마다 15분정도 회의를 가져라, 항상 팀단위로 생각하라
  * 구분없는 열린 공간을 유지하여 원활한 의사소통을 하라

### 이벤트 기반
- 최소한의 결합을 지원한다.
- 이벤트 생성자와 소비자로 구성 되어 있으며 생성자는 이벤트를 감지하여 메세지로 나타낸다. 생성자는 소비자 또는 이벤트 결과를 알지 못한다.
- 이벤트 감지 후헤는 이벤트 채널을 통해 소비자로 전송된다.

### 서비스 지향
- 마이크로서비스와 유사하며 별개의 재사용 가능한 서비스 단위로 분할 한다.
- 특정 비지니스 프로세스를 기반으로 구성된 개별 서비스가 통신 프로토콜을 준수하며 ESB(Enterprise Service Bus)의 플랫폼을 통해 공유된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-5-1-BackEnd)/[참고자료](https://atoz-develop.tistory.com/entry/소프트웨어-개발-방법론-애자일Agile-방법론)

</br>

---
