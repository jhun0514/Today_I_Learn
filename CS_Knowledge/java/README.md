# Part 4-1 Java

* [JVM](#JVM)
* [Static](#Static)
* [final](#final)
* [this](#this)
* [Enum](#Enum)
* [Shift](#Shift)
* [Annotation](#Annotation)
* [오버로딩 vs 오버라이딩](#오버로딩-vs-오버라이딩)
* [상속](#상속)
* [super](#super)
* [abstract](#abstract)
* [interface](#interface)
* [변수의 종류](#변수의-종류)
* [패키지](#패키지)
* [Lambda](#Lambda)
* [Lombok](#Lombok)
* [JPA](#JPA)
* [예외처리](#예외처리)

[뒤로](https://github.com/jhun0514/Today_I_Learn)

</br>

---

## JVM

- 의미: JVM은 Java Virtual Machine의 약자로, 자바 가상머신(프로그램의 실행을 위해 물리적 머신과 유사한 소프웨어로 구현한 머신)의 줄임말이다. 스택기반의 가상머신이다.
- 역할: 자바 어플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것. 그리고 Java 와 OS 사이에서 중개자 역할을 수행하여 OS에 구애받지 않고 재사용을 가능하게 해준다. 또한 Garbage Collection, 메모리관리를 수행한다.
- 알아야 하는 이유: 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기위해서 메모리 구조를 알아야하기에 JVM에 대> 알아야한다.
- 실행과정:
  * 프로그램이 실행되면 JVM은 OS로 부터 프로그램이 필요로 하는 메모리를 할당 받는다. 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
  * 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(class)로 변환시킨다.
  * Class Loader를 통해 class파일들을 JVM으로 로딩한다.
  * 로딩된 class파일들은 Execution engine을 통해 해석된다.
  * 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어진다.
  * 이 과정 속에서 JVM은 필요에 따라 Thread Synchronization 같은 GC 관리작업을 수행한다.
- 구성:
  * Class Loader: JVM내로 클래스파일을 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈이다. 런타임시에 동적으로 클래스를 로드한다. jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다. (컴파일러 역할) 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다. 즉, 클래스를 처음으로 참조할 때, 해당클래스를 로드하고 링크한다는 것이다.
  * Execution Engine: 클래스를 실행시키는 역할. 클래스 로더가 배치시킨 바이트 코드를 실행한다. 자바 바이트 코드는 시계가 수행하는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다. 그래서 실행 엔진은 이와같은 바이트코드를 JVM내부에서 기계가 샐행할 수 있도고 형태를 변경한다. 이때 두가지 방식을 사용한다.
    * Interpreter: 바이트 코드를 명령어 단위로 읽어서 실행한다. 한줄씩 수행하기 때문에 느리다.
    * JIT(just in time): 인터프리터의 단점을 보완하기 위해 도입된 컴파일러로 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행한다. 네이티브 코드는 캐시에 보관하기에 한번 컴파일된 코드는 빠르게 수행하게 된다. 물론 인터프리팅하는 것보다 훨씬 오래걸리기 때문에 한번만 실행되는 코드라면 컴파일 하지 않고 인터프리팅하는 것이 유리하다. 따라서 해당 메서드의 빈도를 체크하고 일정정도를 넘을 때에만 컴파일을 수행한다.
    * Garbage collector: GC를 수행하는 모듈(스레드) 이다
  * Runtime Data Area: 프로그램의 수행을 위해 OS에서 할당받은 메모리 공간. 크게 스레드, 힙, 메서드 공간으로 나뉜다.
    * Thread: PC + JVM Stack + Native Method Stack
      * PC register: 스레드가 시작될때 생성되어 어떤부분을 어떤 명령으로 실행해야할지에 대해 기록하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다.
      * JVM 스택 영역: 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다. 각종 변수나 임시 데이터, 스레드나 메소드의 정보를 저장한다. 메소드 호출시마다 각각의 스택 프레임(메서드를 위한 공간)이 생성된다. 메서드 수행이 끝나면 프레임 별로 삭제를 한다. local variable을 저장한다. 또한 호출된 메서드의 매개변수, 지역변수, 리턴값 등 을 임시로 저장한다.
      * Native Method Stack: 기계어로 작성된 프로그램을 실행시키는 영역이다. java가 아닌 다른언어로 작성된 코드를 위한공간. JAVA Native Interface를 통해 바이트 코드로 전환하여 저장하게 된다. 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다. 이부분을 통해 C code를 실행시켜 Kernel에 접근할 수 있다.
    * Heap
    * 메서드 공간: 클래스 정보를 처음 메모리에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간. 올라가게 되는 메소드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드이다. 자바는 main메서드의 호출에서 부터 계속된 메소드의 호출로 흐름을 이어가기 때문이다. 대부분의 인스턴스 생성도 메서드 내에서 명령하고 호출한다. 컴파일된 바이트코드의 대부분이 메소드 바이트코드이기에 거의 모든 바이트코드가 올라간다고 봐도 된다. 이 공간에는 Runtime Constant Pool이라는 별도의 관리 영역이 있는데 이는 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행한다. Heap과 마찬가지로 GC의 관리대상에 포함된다. 이게 클래스 데이터를 위한 공간이라면 heap은 객체를 위한 공간
      * 올라가는 정보의 종류로는
      * Field Information:  멤버변수의 이름, 데이터 타입, 접근 제어자의 정보
      * Method Information: 메소드 이름, 리턴타입, 매개변수, 접근제어자의 정보
      * Type Information: class인지 interface인지의 여부 저장, type의 속성, 전체 이름, super class의 전체 이름(interface, object의 경우 제외)
    * Heap: 객체를 저장하는 가상 메모리 공간. new로 생선된 객체와 배열을 저장한다. 물론 class area 영역에 올라온 클래스들만 객체로 생성할 수 있다. 크게 permanent generation, new/young generation, tenured generation(old)로 나뉜다. 인스턴스는 소멸방법과 시점이 지역변수와는 다르기에 힙에 할당된다. 더이상 인스턴스의 존재이유가 없을 때 소멸시킨다.
      * Permanent Generation: 객체들의 정보 주소값이 저장된 공간. class loader에 의해 로드되는 클래스, 메서드 등에 대한 메타정보가 저장되는 영역이고 JVM에 의해 사용된다. reflection 을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 리플랙션을 자주사용하는 스프링 프레임워크의 경우 이영역애 대한 고려가 필요하다.
      * New/Young Generation
        * Eden: 객체들이 최초로 생성되는 공간
        * Survivor: Eden에서 참조되는 객체들이 저장되는 공간
      * Tenured Generation(Old): New area에서 일정시간 참조되고있는 살아남은 객체들이 저장되는 공간. Eden 영역에 객체가 가득차면 첫번째 GC(minor GC)가 발생한다. Eden 영역에 있는 값들을 Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체를 삭제한다.      

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://asfirstalways.tistory.com/158)

</br>

---

## Static

- 의미: 객체에 소속된 멤버가 아닌 클래스에 고정된 정적 필드와 정적 메소드 (클래스 멤버)를 만든다. 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있다.

- 특징:
  * Garbage Collector 의 관리 영역 밖에 존재하기에 프로그램의 종료시 까지 메모리가 할당된 채로 존재하게 된다. 그렇기에 너무 남발하면 시스템의 성능에 악영향을 줄 수 있다.
  * static 메소드의 경우 인스턴스를 생성하지 않아도 호출이 가능하다.
  * static 변수의 값을 증가 시키면 저장공간을 공유하기에 값을 항상 저장하고 있다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](##part-4-1-Java)/[참고자료](https://coding-factory.tistory.com/524)

</br>

---

## final

- 의미: final 필드는 초기값이 저장되면 최종적인 값이 되어 프로그램 실행 도중에 수정을 할 수 없다.

- 특징:
  * final 필드: 초기값을 주는 방법은 두가지로 필드선언시에 주는 방법 또는 생성자를 통해서 주는 방법이다. 만약 초기화가 되지 않은 final 필드가 있다면 컴파일 에러가 발생한다.
  * final 객체: final 객체는 다른 참조 값을 지정할 수 없다. 즉 한번 생성되면 같은 타입으로 재생성이 불가하다. 객체 내부 변수는 변경 가능 하다.
  * final 클래스: 상속이 불가능하다.필드는 setter 함수로 변경은 가능하다.
  * final 메서드: 부모의 final 메서드는 재정의 할 수 없다.
  * final 인자값: 마찬가지로 인자값 변경이 불가하다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)

</br>

---

## this

- 의미: 인자값의 변수를 필드의 이름과 같이 하려할때 사용한다. 메서드의 인수나 변수에 필드와 같은 이름을 붙여도 그것들을 구분하여 사용할 수 있다. 주로, 생성자와 메소드의 매개변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://coding-factory.tistory.com/523?category=758267)

</br>

---

## Enum

- 의미: 열거 타입을 선언하기 위한 키워드이다. 열거 타입이름을 지정하고 열거 상수를 나열하면 된다. 열거 타입 이름으로 소스파일(.java)를 생성하여도 된다.

- 장점:
  * 문자열과 비교해, IDE의 적극적인 지원을 받을 수 있습니다.
  * 허용 가능한 값들을 제한할 수 있습니다.
  * 리팩토링시 변경 범위가 최소화 됩니다

- 관련 메서드:
  * Ordinal(): 전체 열거 객체 중 몇번째 열거 객체인지 알려준다.(0 부터 시작)
  * valueOf(): 매개 값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.
  * name(): 열거 객체가 가지고 있는 문자열을 리턴한다. 리턴되는 문자열은 열거 타입을 정의할때 사용한 상수 이름과 동일하다.
  * compareTo(): 매개값으로 주어진 열거 객체를 기준으로 전후로 몇번째 위치하는지 비교한다. 순번이 빠르다면 음수, 늦다면 양수가 리턴 된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)

</br>

---

## Shift

- 의미: 비트 연산자로 데이터를 비트 단위로 연산한다. 기능에 따라 비트 이동연산자, 비트 논리연산자로 구분한다.

- 비트 이동 연산자:
  * x << y: 정수 x의 각 비트를 y만큼 왼쪽으로 이동시킨다. (빈자리는 0으로 채워진다.)
  * x >> y: 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킨다. (빈자리는 정수 x의 최상위 부호비트와 같은 값으로 채워진다.)
  * x >>> y: 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킨다. (빈자리는 0으로 채워진다.)

- 비트 논리 연산자:
  * &: 두 비트 모두 1일 경우에 연산 결과 1
  * |: 두 비트 중 하나만이라도 1일 경우에 연산 결과 1
  * ^: 두 비트 중 하나는 1 하나는 0일 경우에 연산 결과 1
  * ~: 비트 반전(보수)

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://coding-factory.tistory.com/521?category=758267)

</br>

---

## Annotation

- 의미: 용도는 다양한 목적이 있지만 메타 데이터 (데이터를 위한 데이터, 한 데이터에 대한 설명을 의미하는 데이터) 의 비중이 가장 크다.

- 기본 종류:
  * Override: 선언한 메서드가 오버라이드 되었다는 것을 나타낸다.
  * Deprecated: 해당 메서드가 더이상 사용되지 않음을 표시한다.
  * SuppressWarnings: 선언한 곳의 컴파일 경고를 무시하도록 한다.
  * SafeVarargs: 제너릭 같은 가변인자의 매개변수를 사용할 때의 경고를 무시한다.
  * FunctionalInterface: 함수형 인터페이스를 지정하는 어노테이션이다.

- 메타 어노테이션 종류:
  * Retention: 자바 컴파일러가 어노테이션을 다루는 방법을 기술하며, 특정 시점까지 영향을 미치는지를 결정한다.
  * Target: 어노테이션이 적용할 위치를 선택한다.
  * Documented: 해당 어노테이션을 javadoc에 포함시킨다.
  * Inherited: 어노테이션의 상속을 가능하게 한다.
  * Repeatable: 연속적으로 어노테이션을 선언할 수 있게 해준다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://elfinlas.github.io/2017/12/14/java-annotation/)

</br>

---

## 오버로딩 vs 오버라이딩

### 오버로딩
- 의미: 같은 이름의 메서드를 여러개 가지면서 매개변수의 유형과 개수가 다르게 하는 기술


### 오버라이딩
- 의미: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용
- 특징: super 예약어로 덮어쓸수있다.

### 차이점
- 메서드이름: 오버로딩: 동일 / 오버라이딩: 동일
- 매개변수, 타입: 오버로딩: 다름 / 오버라이딩: 동일
- 리턴 타입: 오버로딩: 상관없음 / 오버라이딩: 동일

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://private.tistory.com/25)

</br>

---

## 상속

- 의미: 부모의 유산을 물려받는다. 즉, 상속(extends)을 통해 기존에 있던 클래스를 이용하여 새로운 클래스를 만들 수 있다. 적은 양의 코드로 새로운 클래스를 만들 수 있다는 장점이 있다.
- 특징:
  * 2개 이상의 클래스를 한번에 상속 받을 수는 없다.
  * 부모의 생성자는 상속되지 않는다.
  * 부모의 멤버변수와 메서드를 모두 상속받는다.
  * 부모에서 private 접근 제한자를 사용하면 멤버변수는 상속받으나 바로 접근이 불가하고 메서드의 경우 상속되지 않는다.
  * static 메서드나 변수도 상속된다.
  * 동일한 이름의 변수가 부모 자식 모두 존재할 경우 부모의 변수는 가려진다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://private.tistory.com/27?category=655783)

</br>

---

## super

- 의미: super 예약어를 사용하면 상위클래스의 생성자에도 접근할 수 있다.
- 특징:
  * 부모 클래스의 멤버 변수에 접근: super.멤버변수
  * 부모 클래스의 멤버 메서드에 접근: super.멤버메서드(매개변수)
  * 부모 클래스의 생성자 호출: super(매개변수)
- 주의사항:
  * 반드시 자식클래스의 생성자 첫라인에서 부모의 생성자를 호출해야한다.
  * 자식클래스의 생성자 내에서 반드시 부모의 생성자를 호출해야 한다.(에러는 나지 않는다 가상머신에의해 디폴트 생성자가 알아서 추가된다.)
  * 명시적으로 자식에서 부모의 생성자를 호출하지 않아도 super가 자동 삽입되어 부모의 생성자를 호출한다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://private.tistory.com/27?category=655783)

</br>

---

## abstract

- 추상 메서드 의미: 내용이 없는 메서드, 구현하지 않고 선언만 한 메서드. 메서드의 내용이 너무 일반적이라 부모에서 구체화하여 정의할 필요 없을 경우 추상메서드로 선언만 하고 자식에서 재정의 하도록 한다.
- 추상 클래스 의미: 한개 이상의 추상메서드를 가지는 클래스. 추상메서드는 객체로 생성되어서는 안되기에 클래스를 추상클래스로 선언하여 객체 생성을 금지 시킨다. 하지만 슈퍼클래스로 사용할 수는 있다.
- 특징:
  * 추상 메서드를 재정의 하지 않을 경우 컴파일러는 에러를 발생시킨다.
  * 추상 클래스는 해달 클래스를 통해 만들어낸 객체가 전혀 객체의 모습을 띄지 못할때 해달 클래스가 객체를 생성할 수 없도록 사용된다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://private.tistory.com/20?category=655783)

</br>

---

## interface

- 의미: 추상 클래스와 비슷한 기능을 하지만 극단적인 경우이다. 추상메서드와 상수로만 이루어져 있다.(로직을 작성할 수 없다). 다중 상속이 가능하다.
- 특징:
  * 클래스에 인터페이스 상속 시 인터페이스 내에 정의된 모든 추상메서드를 구현해야만 정상적인 컴파일이 가능하다.

### 인터페이스와 추상클래스의 공통점
- 선언만 있고 구현 내용이 없다.
- 자기 자신이 new를 통해 객체를 생성할 수 없고 자식만이 객체를 생성할 수 있다.
- 상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다.
- type이 자식과 같아야만 한다.

### 차이점
- 인터페이스
  * 구현 객체의 같은 동작을 보장하기 위함
  * 다중 상속 가능
  * 추상메서드만 가능
  * 상수+추상메서드 형태
  * 생성자와 일반변수를 가질 수 없음
  * implements 로 상속
  * 메서드 선언만 가능
- 추상클래스
  * 추상클래스를 상속받아 기능을 이용하고 확장시키기 위해 사용
  * 다중 상속 불가능
  * 일반메서드 + 추상메서드 가능
  * 일반변수 + 일반메서드 + 추상메서드 형태
  * 생성자와 일반 변수 모두 가질 수 있음
  * extends 로 상속
  * 메서드의 부분적 구현 가능
  * 자식이 일반메서드는 사용하지 않아도 문제 없다
- 정리 해보자면 인터페이스는 다형성에 초점, 추상은 부모-자식 관계로 부모가 가진 기능을 쓰거나 발전시킨다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://private.tistory.com/20?category=655783)

</br>

---

## 변수의 종류

### Data Type에 따른 분류
- 기본형 변수 [참조](https://itsuit.tistory.com/47)
  * 논리형: boolean
  * 문자형: char
  * 정수형: byte, short, int, long
  * 실수형: float, double
- 참조 변수: 값이 저장되어 있는 주소값을 변수값으로 갖는다.

### 선언 위치에 따른 분류
- 멤버 변수: 클래스 영역에 선언된 변수
  * 클래스 변수: static이 붙은 변수, 값을 공유, 생성 없이 바로 쓸 수 있다
  * 인스턴스 변수: 인스턴스 생성시 만들어짐, 각각 다른 값, 생성이 필수이다.
- 지역 변수: 메소드 내에 선언되며 메소드 호출시 생성되고 종료되면 사라진다.
- 매개 변수: parameter, 입력값을 받을때 사용되는 변수 (지역변수에 들어간다)

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://sleepyeyes.tistory.com/28)

</br>

---

## 패키지

- 의미: 클래스를 모아넣는 디렉토리로 예로 java.lang.System 클래스는 java패키지의 하위 패키지인 lang에 속한 (java 밑의 lang 밑의 System.class 파일이다)
- 특징:
  * 모든 클래스파일은 패키지 안에 들어있어야 한다.
  * 패키지는 또다른 패키지 파일에 넣을 수 있다.
  * 패키지는 소스파일 첫번째 문장으로 단한번 선언한다.
  * 같은 소스파일의 클래스들은 모든 같은 패키지에 속하게 된다.
  * 패키지 선언이 없으면 이름 없는 패키지에 속하게 된다.

### java.lang
- import 문으로 호출하지 않아도 기본적으로 로딩되는 패키지로 이 패키지가 자바의 기본 클래스와 인터페이스를 제공하고 있다.
- java.lang.Object 클래스는 최상위 클래스이며, JDK에서 제공하는 모든 패키지의 최상위 클래스이다.

### java.util
- 날짜 관련, 수학 관련, 자료구조와 관련된 클래스 (List, Map, Set, Collection.. etc) 등 유용한 클래스들을 많이 가지고 있다.
- Date 클래스는 지역화를 지원하지 않는다. (국가별 날짜, 시간 등) (Calendar 클래스로 해결)

### 그외
- 그외 패키지들은 참고자료에 나와있다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://itellyhood.tistory.com/78)

</br>

---

## Lambda

- 의미: 람다 함수는 프로그래밍 언어에서 사용되는 개념으로 익명 함수를 지칭하는 용어이다. 간단히, 수학에서 사용하는 함수를 단순하게 표현하는 방법이다.
- 특징:
  * 람다 대수는 이름을 가질 필요가 없다. Anonymous Function
  * 두 개 이상의 입력이 있는 함수는 최종적으로 1개의 입력만 받는 람다 대수로 단순화 될 수 있다. Curring
  * 일급객체( 다른 객체들에 적용 가능한 연산을 모두 지원하는 개체)의 특징을 가지고 있다.

### 장점
- 코드의 간결성. 불필요한 반복문의 삭제가 가능하다
- 지연연산 수행. 지연연산으로 불필요한 연산을 최소화 한다.
- 병렬처리 가능. 멸티 쓰레디를 활용하여 병렬처리를 사용 할 수 있다.

### 단점
- 호출이 까다롭다.
- 람다 stream 사용 시 단순 for문 혹은 while문 사용시 성능이 떨어진다
- 너무 사용하면 가독성이 떨어진다.

### 표현식
- 매개변수 화살표(->) 함수 몸체로 사용한다.
- 함수몸체가 단일 실행문이면 괄호({})를 생략 할 수 있다.
- 함수몸체가 return문으로만 구성되어 있으면 괄호를 생략할 수 없다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://khj93.tistory.com/entry/JAVA-람다식Rambda란-무엇이고-사용법)

</br>

---

## Lombok

- 의미: 롬복은 java 라이브러리로 반복되는 getter, setter, toString 등의 메서드 작성 코드를 줄여주는 코드 다이어트 라이브러리이다.
- 특징:
  * 가독성이 올라가고 생산성이 올라간다.
  * 충분한 숙지 없이 사용시 에러가 발생할 수 있다.(ToString)의 경우 스택오버플로우가 발생할 수 있다.

### 단점
- 직관성이 떨어진다.

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://dololak.tistory.com/783)

</br>

---

## JPA

- 의미: JPA는 Java Persistence API 이다. Persistence는 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다.
- 특징:
  * JPA는 ORM(Object Relational Mapping) 기술이다. 오브젝트를 데이터베이스에 열결하는 방법론이다.
  * JPA가 가지고 있는 인터페이스를 통해서 자바에서 클래스를 만들어 데이터베이스 테이블이 자동으로 생성되게 하는 것을 ORM이라 한다.
  * JPA는 반복적인 CRUD 작업을 생략하게 해준다.
  * JPA는 영속성 컨텍스트를 가지고 있다.
  * DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다.

### 단점
- 이해하고 사용하지 않으면 데이터 손실이 있을 수 있다.
- 성능상 문제가 있을 수 있다.(잘 이해해야 해결이 가능하다)

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://blog.woniper.net/255)

</br>

---

## 예외처리

- 의미: 에러가 날 때 그에 맞는 적절한 처리를 도와준다.

### try catch
- try 안에 수행할 문장에서 예외가 발생하지 않는다면 catch 안 문장들은 수행 되지 않는다.
- ex)
```java
    int c;
    try {
        c = 4 / 0;
    }catch(ArithmeticException e) {
        c = -1;
    }
```

### finally
- 예외발생 여부에 상관없이 무조건 실행해야 하는 코드를 수행한다.
- ex)
```java
    int c;
    try {
        c = 4 / 0;
    } catch (ArithmeticException e) {
        c = -1;
    } finally {
        test.shouldBeRun();
    }
```

### throw
- 원하는 결과가 아닐때 예외를 직접 발생시킨다.
- ex)
```java
    if("fool".equals(nick)) {
        throw new FoolException();
    }
```

### throws
- function을 호출한 곳에서 예외를 처리하도록 하는 방법이다.
- 호출할 때 try catch 를 써야한다.
- ex)
```java
    public void sayNick(String nick) throws FoolException {
        if("fool".equals(nick)) {
            throw new FoolException();
        }
        System.out.println("당신의 별명은 "+nick+" 입니다.");
    }
```

[뒤로](https://github.com/jhun0514/Today_I_Learn)/[위로](#part-4-1-Java)/[참고자료](https://wikidocs.net/229)

</br>

---
